//
//  RestaurantsInteractor.swift
//  FoodDelivery
//
//  Created Galean Pallerman on 16.08.2019.
//  Copyright Â© 2019 GPco. All rights reserved.
//
//  Template generated by Galean Pallerman
//

import Foundation

class RestaurantsInteractor: NSObject {
    fileprivate unowned var presenter: RestaurantsInteractorToPresenterProtocol
    
    lazy var restaurantsModel: RestaurantsModelProtocol = {
        let model = RestaurantsModel()
        model.delegate = self
        return model
    }()
    
    lazy var currentCityModel: CurrentCityModelProtocol = {
        let model = CurrentCityModel()
        model.delegate = self
        return model
    }()

    //MARK: Initialization
    init(with presenter: RestaurantsInteractorToPresenterProtocol) {
        self.presenter = presenter
        
        super.init()
    }
}

//MARK:- RestaurantsPresenterToInteractorProtocol
extension RestaurantsInteractor: RestaurantsPresenterToInteractorProtocol {
    var currentCityName: String {
        return currentCityModel.currentCityName ?? ""
    }
    
    func restaurantsSectionsNumber() -> Int {
        return restaurantsModel.sectionNames.count
    }
    
    func restaurantsSections() -> [String] {
        return restaurantsModel.sectionNames
    }
    
    func restaurantsCount(for section: Int) -> Int {
        guard section < restaurantsModel.sectionNames.count else{
            assert(false)
            return 0
        }
        
        let restaurantsForSection = restaurantsModel.restaurantsForSection[section]
        
        return restaurantsForSection.count
    }
    
    func restaurantData(for indexPath: IndexPath) -> RestaurantStruct {
        let section = indexPath.section
        
        guard section < restaurantsModel.sectionNames.count else{
            assert(false)
            fatalError() // Or some workaround for non-failable application
        }
        
        let restaurants = restaurantsModel.restaurantsForSection[section]
        
        let item = indexPath.item
        
        guard item < restaurants.count else {
            assert(false)
            fatalError() // Or some workaround for non-failable application
        }
        
        return restaurants[item]
    }
    
    func restaurantChosen(at indexPath: IndexPath) {
        
    }
    
    func fetchCurrentCity() {
            presenter.updatingCurrentCity(true)
            currentCityModel.fetchCurrentCity()
    }
    
    func requestCities() {
        presenter.callCityPicker()
    }
}

extension RestaurantsInteractor: RestaurantsModelDelegate {
    var currentCity: City? {
        return currentCityModel.currentCity
    }

    func fetchedRestaurants() {
        presenter.restaurantsFetched()
    }
}

extension RestaurantsInteractor: CurrentCityModelDelegate {
    func fetchedCurrentCity() {
        restaurantsModel.fetchRestaurants()
        presenter.updatingCurrentCity(false)
    }
}
